//숨박꼭질
//너비우선탐색 BFS -> 모든 곳을 똑같이 조금씩 조금씩 팜 
//깊이우선탐색 DFS -> 한 우물만 계속파다 끝을 보고 옮김

#include <cstdio>
#include <queue>
using namespace std;

int n, k, visited[100001] = { 0, };
queue<int> q;

int bfs() {

	//큐에 수빈의 위치 n 삽입, 수빈이 방문한 곳 체크를 위해 배열에 1을 넣는다.
	q.push(n); //큐에 수빈의 위치 넣음
	visited[n] = 1; // 수빈위치 방문했다고 1걸어줌

	//bfs 기작

	while (!q.empty()) { //q가 차있으면 계속 돌아감
		
		//큐를 꺼내서, 수빈이가 동새의 위치에 도달했는지 확인한다.
		int p = q.front(); //q에 가장 먼저 들어간 수빈위치 p에 대입
		q.pop(); //q에 가장 먼저 들어간 수빈위치 삭제

		if (p == k) //수빈과 동생k의 위치가 같다면
			return visited[p] - 1; //수빈 위치의 원소에서 -1 하면 return 0
		
		//수빈이 현재 위치 -1이 0보다 크거나 같고, 방문한 적이 없을 경우, 
		//현재값에서 레벨 1증가시켜 큐에 넣어준다.

		if (p-1 >= 0 && visited[p-1])
	}


}


int main() {




}


/*

Breadth-First Search BFS는 맹목적 탐색방법의 하나로
시작정점을 방문한 후 시작정점에 인접한 모든 정점들을 우선 방문하는 방법이다.
더이상 방문하지 않은 정점이 없을 때까지
방문하지 않은 모든 정점들에 대해서도 넓이 우선 검색을 적용한다.

장점 : 출발 노드에서 목표노드까지의 최단길이 경로를 보장한다.
단점 :
1. 경로가 매우 길 경우에는 탐색가지가 급격히 증가함에 따라 보다 많은 기억공간을 필요로 하게 된다.
2. 해가 존재하지 안는다면 finite 그래프의 경유에는 모든 그래프를 탐색한 후 실패로 끝난다.
3. infinite 그래프의 경우에는 결코 해를 찾지도 못하고 끝내지도 못한다.


*/